<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://diamond153.github.io</id>
    <title>Diamond_153&apos;s Blog</title>
    <updated>2023-08-30T11:00:42.747Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://diamond153.github.io"/>
    <link rel="self" href="https://diamond153.github.io/atom.xml"/>
    <subtitle>diamond_153 的博客</subtitle>
    <logo>https://diamond153.github.io/images/avatar.png</logo>
    <icon>https://diamond153.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Diamond_153&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[积累几个C++14及以前好用但冷门的函数们]]></title>
        <id>https://diamond153.github.io/post/weird-functions/</id>
        <link href="https://diamond153.github.io/post/weird-functions/">
        </link>
        <updated>2023-08-29T03:02:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="numeric">numeric</h2>
<ol>
<li>
<p><code>accumulate</code></p>
<ul>
<li>传入两个迭代器，一个数值：<code>beg,end,val</code>，可传入第四个参数作为加法。</li>
<li>将 <code>[beg,end)</code> 的数据全部加上 <code>val</code> 并返回累加值（与 <code>val</code> 同类型）。</li>
</ul>
</li>
<li>
<p><code>partial_sum</code></p>
<ul>
<li>传入三个迭代器：<code>beg,end,beg2</code>，可传入第四个参数作为加法。</li>
<li>将 <code>[beg,end)</code> 的数据做前缀和从 <code>beg2</code> 开始存储。</li>
</ul>
</li>
<li>
<p><code>adjacent_difference</code></p>
<ul>
<li>与 <code>partial_sum</code> 同理，<code>adjacent_difference</code> 用来求差分。</li>
</ul>
</li>
</ol>
<h2 id="algorithm">algorithm</h2>
<ol>
<li>
<p><code>nth_element</code></p>
<ul>
<li>传入三个迭代器：<code>beg,nth,end</code>，可传入第四个参数作为小于。</li>
<li>执行完后，<code>[beg,nth)</code> 的元素均小于 <code>nth</code> 地址的元素，<code>(nth,end)</code> 的元素均大于 <code>nth</code>地址的元素，<code>nth</code> 地址的元素是原数列第 <code>nth-beg</code> 大，复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，比 <code>sort</code> 后求 <code>nth</code> 要快（注意执行完后原数列已经改变）。</li>
</ul>
</li>
<li>
<p><code>rotate</code></p>
<ul>
<li>传入三个迭代器：<code>beg,mid,end</code>。</li>
<li>把 <code>[beg,mid)</code> 与 <code>[mid,end)</code> 互换，如当 <code>beg=a+0,mid=a+2,end=a+5</code> 时，<code>1 2 3 4 5</code> 变为 <code>3 4 5 1 2</code>。</li>
</ul>
</li>
</ol>
<h2 id="gnu的奇妙双下划线函数">GNU的奇妙双下划线函数</h2>
<ol>
<li><code>__lg(x)</code>
<ul>
<li>返回 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⌊</mo><msub><mi>log</mi><mo>⁡</mo><mn>2</mn></msub><mi>x</mi><mo>⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor\log _2 x\rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">⌋</span></span></span></span>，复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
</li>
<li><code>__gcd(x,y)</code>
<ul>
<li>顾名思义，但注意返回值不一定为正。</li>
</ul>
</li>
<li><code>__builtin_popcount(x)</code>
<ul>
<li>返回 <code>x</code> 在二进制下 <code>1</code> 的个数，复杂度未知，可能 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，可能 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>log</mi><mo>⁡</mo><mi>log</mi><mo>⁡</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(\log \log x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
</li>
<li><code>__builtin_parity(x)</code>
<ul>
<li>返回 <code>x</code> 在二进制下 <code>1</code> 的奇偶，等价于 <code>__builtin_popcount(x)&amp;1</code>，但 <code>__builtin_parity(x)</code> 更快，复杂度 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
</li>
<li><code>__builtin_sqrt(x)</code> 和 <code>__builtin_sqrtf(x)</code>
<ul>
<li>返回 <code>x</code> 的平方根（浮点数），比 <code>&lt;cmath&gt;</code> 的 <code>sqrt</code> 要快约十倍，且精度差的不多，上面两个函数 <code>__builtin_sqrt</code> 精度比 <code>__builtin_sqrtf</code> 精度高，可以用来快速求 <code>x</code> 平方根整数部分。</li>
</ul>
</li>
</ol>
<p>整理可能不太完全，感谢阅读！</p>
]]></content>
    </entry>
</feed>